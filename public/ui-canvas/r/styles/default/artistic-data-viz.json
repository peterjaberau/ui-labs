{
  "name": "artistic-data-viz",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion"
  ],
  "files": [
    {
      "path": "ui-canvas/artistic-data-viz.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport {\n  Settings2,\n  ZoomIn,\n  ZoomOut,\n  Download,\n  Share2,\n  Pause,\n  Play,\n} from \"lucide-react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { useTheme } from \"next-themes\";\n\nexport interface DataPoint {\n  id: string;\n  value: number;\n  label: string;\n  color?: string;\n  category?: string;\n  timestamp?: Date;\n  metadata?: Record<string, any>;\n}\n\ninterface DataPointWithPosition extends DataPoint {\n  x: number;\n  y: number;\n}\n\nexport interface ArtisticDataVizProps {\n  data: DataPoint[];\n  width?: number;\n  height?: number;\n  colorPalette?: string[];\n  animated?: boolean;\n  style?:\n    | \"wave\"\n    | \"circle\"\n    | \"spiral\"\n    | \"bloom\"\n    | \"bar\"\n    | \"line\"\n    | \"scatter\"\n    | \"area\";\n  className?: string;\n  onDataPointClick?: (point: DataPoint) => void;\n  onShare?: (imageData: string) => void;\n  onDownload?: (imageData: string) => void;\n}\n\nexport default function ArtisticDataViz({\n  data,\n  width = 600,\n  height = 400,\n  colorPalette = [],\n  animated = true,\n  style = \"wave\",\n  className,\n  onDataPointClick,\n  onShare,\n  onDownload,\n}: ArtisticDataVizProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [selectedStyle, setSelectedStyle] = useState(style);\n  const [hoveredPoint, setHoveredPoint] =\n    useState<DataPointWithPosition | null>(null);\n  const [isPaused, setIsPaused] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [animationSpeed, setAnimationSpeed] = useState(1);\n  const [zoomLevel, setZoomLevel] = useState(1);\n  const [showMetadata, setShowMetadata] = useState(false);\n  const [categoryFilter, setCategoryFilter] = useState<string | null>(null);\n  const [valueThreshold, setValueThreshold] = useState<number>(0);\n  const [showGrid, setShowGrid] = useState(false);\n  const [smoothing, setSmoothing] = useState(0.5);\n  const { theme } = useTheme();\n\n  // Default theme-aware color palettes\n  const defaultLightPalette = [\n    \"#FF6B6B\",\n    \"#4ECDC4\",\n    \"#45B7D1\",\n    \"#96CEB4\",\n    \"#FFEEAD\",\n  ];\n  const defaultDarkPalette = [\n    \"#FF8585\",\n    \"#6FFFE9\",\n    \"#5CC9FF\",\n    \"#B4EBC7\",\n    \"#FFE5B4\",\n  ];\n\n  const effectiveColorPalette =\n    colorPalette.length > 0\n      ? colorPalette\n      : theme === \"dark\"\n        ? defaultDarkPalette\n        : defaultLightPalette;\n\n  const filteredData = data.filter(\n    (point) =>\n      (!categoryFilter || point.category === categoryFilter) &&\n      point.value >= valueThreshold,\n  );\n\n  const handleZoomIn = () => setZoomLevel((prev) => Math.min(prev + 0.2, 3));\n  const handleZoomOut = () => setZoomLevel((prev) => Math.max(prev - 0.2, 0.5));\n\n  const handleShare = () => {\n    if (!canvasRef.current || !onShare) return;\n    onShare(canvasRef.current.toDataURL());\n  };\n\n  const handleDownload = () => {\n    if (!canvasRef.current || !onDownload) return;\n    onDownload(canvasRef.current.toDataURL());\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = width * dpr * zoomLevel;\n    canvas.height = height * dpr * zoomLevel;\n    ctx.scale(dpr * zoomLevel, dpr * zoomLevel);\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    // Theme-aware background and grid colors\n    const backgroundColor = theme === \"dark\" ? \"#1a1a1a\" : \"#ffffff\";\n    const gridColor =\n      theme === \"dark\" ? \"rgba(255, 255, 255, 0.1)\" : \"rgba(0, 0, 0, 0.1)\";\n\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width, height);\n\n    if (showGrid) {\n      drawGrid(ctx, width, height, gridColor);\n    }\n\n    const drawVisualization = () => {\n      ctx.clearRect(0, 0, width, height);\n\n      if (showGrid) {\n        drawGrid(ctx, width, height, gridColor);\n      }\n\n      switch (selectedStyle) {\n        case \"wave\":\n          drawWave(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"circle\":\n          drawCircle(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"spiral\":\n          drawSpiral(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"bloom\":\n          drawBloom(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"bar\":\n          drawBar(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"line\":\n          drawLine(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"scatter\":\n          drawScatter(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n        case \"area\":\n          drawArea(\n            ctx,\n            filteredData,\n            width,\n            height,\n            effectiveColorPalette,\n            animationSpeed,\n            smoothing,\n          );\n          break;\n      }\n    };\n\n    if (!isPaused && animated) {\n      let animationFrame: number;\n      const animate = () => {\n        drawVisualization();\n        animationFrame = requestAnimationFrame(animate);\n      };\n      animate();\n\n      return () => cancelAnimationFrame(animationFrame);\n    } else {\n      drawVisualization();\n    }\n  }, [\n    filteredData,\n    width,\n    height,\n    selectedStyle,\n    effectiveColorPalette,\n    animated,\n    isPaused,\n    zoomLevel,\n    showGrid,\n    animationSpeed,\n    smoothing,\n  ]);\n\n  const handleCanvasClick = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!onDataPointClick) return;\n\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const closestPoint = findClosestDataPoint(\n      x,\n      y,\n      filteredData,\n      width,\n      height,\n    );\n    if (closestPoint) {\n      onDataPointClick(closestPoint);\n      setHoveredPoint({ ...closestPoint, x, y });\n    }\n  };\n\n  const handleCanvasMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const point = findClosestDataPoint(x, y, filteredData, width, height);\n    if (point) {\n      setHoveredPoint({ ...point, x, y });\n    } else {\n      setHoveredPoint(null);\n    }\n  };\n\n  const handleCanvasMouseLeave = () => {\n    setHoveredPoint(null);\n  };\n\n  return (\n    <div className={cn(\"relative rounded-lg bg-background p-4\", className)}>\n      <div className=\"flex flex-col gap-4\">\n        <div className=\"flex flex-wrap items-center justify-between\">\n          <div className=\"flex items-center gap-2\">\n            <Select\n              value={selectedStyle}\n              onValueChange={(\n                value:\n                  | \"wave\"\n                  | \"circle\"\n                  | \"spiral\"\n                  | \"bloom\"\n                  | \"bar\"\n                  | \"line\"\n                  | \"scatter\"\n                  | \"area\",\n              ) => setSelectedStyle(value)}\n            >\n              <SelectTrigger className=\"w-[180px]\">\n                <SelectValue placeholder=\"Select style\" />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"wave\">Wave</SelectItem>\n                <SelectItem value=\"circle\">Circle</SelectItem>\n                <SelectItem value=\"spiral\">Spiral</SelectItem>\n                <SelectItem value=\"bloom\">Bloom</SelectItem>\n                <SelectItem value=\"bar\">Bar</SelectItem>\n                <SelectItem value=\"line\">Line</SelectItem>\n                <SelectItem value=\"scatter\">Scatter</SelectItem>\n                <SelectItem value=\"area\">Area</SelectItem>\n              </SelectContent>\n            </Select>\n            <TooltipProvider>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={() => setShowSettings(!showSettings)}\n                  >\n                    <Settings2 className=\"h-4 w-4\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>Toggle Settings</TooltipContent>\n              </Tooltip>\n            </TooltipProvider>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <TooltipProvider>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button variant=\"ghost\" size=\"icon\" onClick={handleZoomOut}>\n                    <ZoomOut className=\"h-4 w-4\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>Zoom Out</TooltipContent>\n              </Tooltip>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button variant=\"ghost\" size=\"icon\" onClick={handleZoomIn}>\n                    <ZoomIn className=\"h-4 w-4\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>Zoom In</TooltipContent>\n              </Tooltip>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={() => setIsPaused(!isPaused)}\n                  >\n                    {isPaused ? (\n                      <Play className=\"h-4 w-4\" />\n                    ) : (\n                      <Pause className=\"h-4 w-4\" />\n                    )}\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>\n                  {isPaused ? \"Resume Animation\" : \"Pause Animation\"}\n                </TooltipContent>\n              </Tooltip>\n              {onShare && (\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button variant=\"ghost\" size=\"icon\" onClick={handleShare}>\n                      <Share2 className=\"h-4 w-4\" />\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent>Share</TooltipContent>\n                </Tooltip>\n              )}\n              {onDownload && (\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      onClick={handleDownload}\n                    >\n                      <Download className=\"h-4 w-4\" />\n                    </Button>\n                  </TooltipTrigger>\n                  <TooltipContent>Download</TooltipContent>\n                </Tooltip>\n              )}\n            </TooltipProvider>\n          </div>\n        </div>\n\n        <AnimatePresence>\n          {showSettings && (\n            <motion.div\n              initial={{ height: 0, opacity: 0 }}\n              animate={{ height: \"auto\", opacity: 1 }}\n              exit={{ height: 0, opacity: 0 }}\n              className=\"space-y-4 overflow-hidden rounded-lg border bg-background/50 p-4 backdrop-blur-sm\"\n            >\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"space-y-2\">\n                  <label className=\"text-sm font-medium\">Animation Speed</label>\n                  <Slider\n                    value={[animationSpeed]}\n                    onValueChange={([value]) => setAnimationSpeed(value)}\n                    min={0.1}\n                    max={2}\n                    step={0.1}\n                  />\n                </div>\n                <div className=\"space-y-2\">\n                  <label className=\"text-sm font-medium\">Smoothing</label>\n                  <Slider\n                    value={[smoothing]}\n                    onValueChange={([value]) => setSmoothing(value)}\n                    min={0}\n                    max={1}\n                    step={0.1}\n                  />\n                </div>\n              </div>\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"flex items-center justify-between\">\n                  <label className=\"text-sm font-medium\">Show Grid</label>\n                  <Switch checked={showGrid} onCheckedChange={setShowGrid} />\n                </div>\n                <div className=\"flex items-center justify-between\">\n                  <label className=\"text-sm font-medium\">Show Metadata</label>\n                  <Switch\n                    checked={showMetadata}\n                    onCheckedChange={setShowMetadata}\n                  />\n                </div>\n              </div>\n              <div className=\"space-y-2\">\n                <label className=\"text-sm font-medium\">Value Threshold</label>\n                <Input\n                  type=\"number\"\n                  value={valueThreshold}\n                  onChange={(e) => setValueThreshold(Number(e.target.value))}\n                  className=\"w-full\"\n                />\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n\n        <div className=\"relative\">\n          <canvas\n            ref={canvasRef}\n            onClick={handleCanvasClick}\n            onMouseMove={handleCanvasMouseMove}\n            onMouseLeave={handleCanvasMouseLeave}\n            className=\"rounded-lg shadow-lg\"\n            style={{\n              width: `${width}px`,\n              height: `${height}px`,\n              cursor: onDataPointClick ? \"pointer\" : \"default\",\n            }}\n          />\n          <AnimatePresence>\n            {hoveredPoint && (\n              <motion.div\n                initial={{ opacity: 0, y: 10 }}\n                animate={{ opacity: 1, y: 0 }}\n                exit={{ opacity: 0, y: 10 }}\n                className=\"absolute rounded-lg bg-white/90 p-2 shadow-lg backdrop-blur-sm\"\n                style={{\n                  left: `${hoveredPoint.x}px`,\n                  top: `${hoveredPoint.y - 40}px`,\n                }}\n              >\n                <p className=\"text-sm font-medium\">{hoveredPoint.label}</p>\n                <p className=\"text-xs text-gray-500\">{hoveredPoint.value}</p>\n                {showMetadata && hoveredPoint.metadata && (\n                  <div className=\"mt-1 space-y-1\">\n                    {Object.entries(hoveredPoint.metadata).map(\n                      ([key, value]) => (\n                        <p key={key} className=\"text-xs text-gray-400\">\n                          {key}: {value}\n                        </p>\n                      ),\n                    )}\n                  </div>\n                )}\n              </motion.div>\n            )}\n          </AnimatePresence>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Drawing functions\nfunction drawWave(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const points = data.length;\n  const amplitude = height / 3;\n  const frequency = (2 * Math.PI) / points;\n\n  data.forEach((point, i) => {\n    const x = (width * i) / (points - 1);\n    const normalizedValue = point.value / Math.max(...data.map((d) => d.value));\n    const y =\n      height / 2 +\n      amplitude *\n        Math.sin(frequency * i + (performance.now() / 1000) * animationSpeed) *\n        normalizedValue;\n\n    ctx.beginPath();\n    ctx.arc(x, y, 4, 0, 2 * Math.PI);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n    ctx.fill();\n\n    if (i > 0) {\n      const prevPoint = data[i - 1];\n      const prevX = (width * (i - 1)) / (points - 1);\n      const prevNormalizedValue =\n        prevPoint.value / Math.max(...data.map((d) => d.value));\n      const prevY =\n        height / 2 +\n        amplitude *\n          Math.sin(\n            frequency * (i - 1) + (performance.now() / 1000) * animationSpeed,\n          ) *\n          prevNormalizedValue;\n\n      ctx.beginPath();\n      ctx.moveTo(prevX, prevY);\n      ctx.lineTo(x, y);\n      ctx.strokeStyle = point.color || colorPalette[i % colorPalette.length];\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n  });\n}\n\nfunction drawCircle(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(width, height) / 3;\n\n  data.forEach((point, i) => {\n    const angle = (i * 2 * Math.PI) / data.length;\n    const normalizedValue = point.value / Math.max(...data.map((d) => d.value));\n    const x = centerX + radius * Math.cos(angle) * normalizedValue;\n    const y = centerY + radius * Math.sin(angle) * normalizedValue;\n\n    ctx.beginPath();\n    ctx.arc(x, y, 6, 0, 2 * Math.PI);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n    ctx.fill();\n\n    if (i > 0) {\n      const prevPoint = data[i - 1];\n      const prevAngle = ((i - 1) * 2 * Math.PI) / data.length;\n      const prevNormalizedValue =\n        prevPoint.value / Math.max(...data.map((d) => d.value));\n      const prevX =\n        centerX + radius * Math.cos(prevAngle) * prevNormalizedValue;\n      const prevY =\n        centerY + radius * Math.sin(prevAngle) * prevNormalizedValue;\n\n      ctx.beginPath();\n      ctx.moveTo(prevX, prevY);\n      ctx.lineTo(x, y);\n      ctx.strokeStyle = point.color || colorPalette[i % colorPalette.length];\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n  });\n}\n\nfunction drawSpiral(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxRadius = Math.min(width, height) / 3;\n\n  data.forEach((point, i) => {\n    const angle = i * 0.5;\n    const normalizedValue = point.value / Math.max(...data.map((d) => d.value));\n    const radius = (maxRadius * i) / data.length;\n    const x = centerX + radius * Math.cos(angle) * normalizedValue;\n    const y = centerY + radius * Math.sin(angle) * normalizedValue;\n\n    ctx.beginPath();\n    ctx.arc(x, y, 4, 0, 2 * Math.PI);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n    ctx.fill();\n\n    if (i > 0) {\n      const prevPoint = data[i - 1];\n      const prevAngle = (i - 1) * 0.5;\n      const prevRadius = (maxRadius * (i - 1)) / data.length;\n      const prevNormalizedValue =\n        prevPoint.value / Math.max(...data.map((d) => d.value));\n      const prevX =\n        centerX + prevRadius * Math.cos(prevAngle) * prevNormalizedValue;\n      const prevY =\n        centerY + prevRadius * Math.sin(prevAngle) * prevNormalizedValue;\n\n      ctx.beginPath();\n      ctx.moveTo(prevX, prevY);\n      ctx.lineTo(x, y);\n      ctx.strokeStyle = point.color || colorPalette[i % colorPalette.length];\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n  });\n}\n\nfunction drawBloom(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxRadius = Math.min(width, height) / 3;\n\n  const time = performance.now() / 2000;\n\n  data.forEach((point, i) => {\n    const angle = (i * 2 * Math.PI) / data.length + time;\n    const normalizedValue = point.value / Math.max(...data.map((d) => d.value));\n    const radius = maxRadius * normalizedValue;\n\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n\n    ctx.beginPath();\n    ctx.arc(x, y, 6, 0, 2 * Math.PI);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n    ctx.fill();\n\n    // Draw petal\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.quadraticCurveTo(\n      centerX + radius * Math.cos(angle - 0.2) * 0.5,\n      centerY + radius * Math.sin(angle - 0.2) * 0.5,\n      x,\n      y,\n    );\n    ctx.quadraticCurveTo(\n      centerX + radius * Math.cos(angle + 0.2) * 0.5,\n      centerY + radius * Math.sin(angle + 0.2) * 0.5,\n      centerX,\n      centerY,\n    );\n    ctx.fillStyle = `${point.color || colorPalette[i % colorPalette.length]}44`;\n    ctx.fill();\n  });\n}\n\nfunction drawBar(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const padding = 40;\n  const barWidth = (width - padding * 2) / data.length;\n  const maxValue = Math.max(...data.map((d) => d.value));\n\n  data.forEach((point, i) => {\n    const normalizedValue = point.value / maxValue;\n    const x = padding + i * barWidth;\n    const barHeight = (height - padding * 2) * normalizedValue;\n    const y = height - padding - barHeight;\n\n    ctx.beginPath();\n    ctx.rect(x, y, barWidth * 0.8, barHeight);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n    ctx.fill();\n\n    // Add animation effect\n    const time = performance.now() / 1000;\n    const glowIntensity = Math.sin(time * animationSpeed + i) * 0.2 + 0.8;\n    ctx.shadowColor = point.color || colorPalette[i % colorPalette.length];\n    ctx.shadowBlur = 10 * glowIntensity;\n    ctx.fill();\n    ctx.shadowBlur = 0;\n  });\n}\n\nfunction drawLine(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const padding = 40;\n  const maxValue = Math.max(...data.map((d) => d.value));\n\n  ctx.beginPath();\n  data.forEach((point, i) => {\n    const normalizedValue = point.value / maxValue;\n    const x = padding + (i * (width - padding * 2)) / (data.length - 1);\n    const y = height - padding - normalizedValue * (height - padding * 2);\n\n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      // Create smooth curves\n      const prevPoint = data[i - 1];\n      const prevX =\n        padding + ((i - 1) * (width - padding * 2)) / (data.length - 1);\n      const prevY =\n        height -\n        padding -\n        (prevPoint.value / maxValue) * (height - padding * 2);\n\n      const cp1x = prevX + (x - prevX) * smoothing;\n      const cp1y = prevY;\n      const cp2x = x - (x - prevX) * smoothing;\n      const cp2y = y;\n\n      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    }\n  });\n\n  // Animate line dash\n  const time = performance.now() / 1000;\n  ctx.setLineDash([5, 5]);\n  ctx.lineDashOffset = -time * animationSpeed * 50;\n\n  ctx.strokeStyle = colorPalette[0];\n  ctx.lineWidth = 3;\n  ctx.stroke();\n  ctx.setLineDash([]);\n\n  // Draw points\n  data.forEach((point, i) => {\n    const normalizedValue = point.value / maxValue;\n    const x = padding + (i * (width - padding * 2)) / (data.length - 1);\n    const y = height - padding - normalizedValue * (height - padding * 2);\n\n    ctx.beginPath();\n    ctx.arc(x, y, 6, 0, 2 * Math.PI);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n    ctx.fill();\n  });\n}\n\nfunction drawScatter(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const padding = 40;\n  const maxValue = Math.max(...data.map((d) => d.value));\n\n  const time = performance.now() / 1000;\n\n  data.forEach((point, i) => {\n    const normalizedValue = point.value / maxValue;\n    const baseX = padding + (i * (width - padding * 2)) / (data.length - 1);\n    const baseY = height - padding - normalizedValue * (height - padding * 2);\n\n    // Add some animated scatter\n    const scatterX = baseX + Math.sin(time * animationSpeed + i) * 10;\n    const scatterY = baseY + Math.cos(time * animationSpeed + i) * 10;\n\n    ctx.beginPath();\n    ctx.arc(scatterX, scatterY, 8, 0, 2 * Math.PI);\n    ctx.fillStyle = point.color || colorPalette[i % colorPalette.length];\n\n    // Add glow effect\n    const glowIntensity = Math.sin(time * animationSpeed + i) * 0.3 + 0.7;\n    ctx.shadowColor = point.color || colorPalette[i % colorPalette.length];\n    ctx.shadowBlur = 15 * glowIntensity;\n    ctx.fill();\n    ctx.shadowBlur = 0;\n  });\n}\n\nfunction drawArea(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  width: number,\n  height: number,\n  colorPalette: string[],\n  animationSpeed: number,\n  smoothing: number,\n) {\n  ctx.clearRect(0, 0, width, height);\n  const padding = 40;\n  const maxValue = Math.max(...data.map((d) => d.value));\n\n  // Draw filled area\n  ctx.beginPath();\n  ctx.moveTo(padding, height - padding);\n\n  data.forEach((point, i) => {\n    const normalizedValue = point.value / maxValue;\n    const x = padding + (i * (width - padding * 2)) / (data.length - 1);\n    const y = height - padding - normalizedValue * (height - padding * 2);\n\n    if (i === 0) {\n      ctx.lineTo(x, y);\n    } else {\n      const prevPoint = data[i - 1];\n      const prevX =\n        padding + ((i - 1) * (width - padding * 2)) / (data.length - 1);\n      const prevY =\n        height -\n        padding -\n        (prevPoint.value / maxValue) * (height - padding * 2);\n\n      const cp1x = prevX + (x - prevX) * smoothing;\n      const cp1y = prevY;\n      const cp2x = x - (x - prevX) * smoothing;\n      const cp2y = y;\n\n      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    }\n  });\n\n  // Complete the area by drawing to the bottom\n  ctx.lineTo(width - padding, height - padding);\n  ctx.lineTo(padding, height - padding);\n\n  // Create gradient fill\n  const gradient = ctx.createLinearGradient(0, 0, 0, height);\n  gradient.addColorStop(0, `${colorPalette[0]}88`);\n  gradient.addColorStop(1, `${colorPalette[0]}11`);\n\n  ctx.fillStyle = gradient;\n  ctx.fill();\n\n  // Animate the area with a moving line\n  const time = performance.now() / 1000;\n  const lineY =\n    height -\n    padding -\n    Math.abs(Math.sin(time * animationSpeed)) * (height - padding * 2);\n\n  ctx.beginPath();\n  ctx.moveTo(padding, lineY);\n  ctx.lineTo(width - padding, lineY);\n  ctx.strokeStyle = colorPalette[0];\n  ctx.setLineDash([5, 5]);\n  ctx.lineDashOffset = time * animationSpeed * 50;\n  ctx.lineWidth = 2;\n  ctx.stroke();\n  ctx.setLineDash([]);\n}\n\nfunction drawGrid(\n  ctx: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  gridColor: string = \"rgba(0, 0, 0, 0.1)\",\n) {\n  const step = 20;\n  ctx.strokeStyle = gridColor;\n  ctx.lineWidth = 0.5;\n\n  for (let x = 0; x <= width; x += step) {\n    ctx.beginPath();\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, height);\n    ctx.stroke();\n  }\n\n  for (let y = 0; y <= height; y += step) {\n    ctx.beginPath();\n    ctx.moveTo(0, y);\n    ctx.lineTo(width, y);\n    ctx.stroke();\n  }\n}\n\nfunction findClosestDataPoint(\n  mouseX: number,\n  mouseY: number,\n  data: DataPoint[],\n  width: number,\n  height: number,\n): DataPoint | null {\n  let closest: DataPoint | null = null;\n  let minDistance = Infinity;\n\n  // Calculate the spacing between points\n  const spacing = width / (data.length + 1);\n\n  // Find the maximum value for scaling\n  const maxValue = Math.max(...data.map((point) => point.value));\n\n  data.forEach((point, index) => {\n    // Calculate x based on index\n    const pointX = spacing * (index + 1);\n    // Calculate y based on value (inverted since canvas y grows downward)\n    const pointY = height - (point.value / maxValue) * height;\n\n    const dx = mouseX - pointX;\n    const dy = mouseY - pointY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closest = point;\n    }\n  });\n\n  return closest;\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}